Level I 

Q1 В чем разница между == и === в JS?
При == сравнении происходит неявное преобразование разных типов к одному. === - строгое сравнение, при котором объекты сравниваются без какого-либо преобразования. Например, при сравнении ("2" == 2) данные сначала приводятся к типу string, результатом будет false. При сравнении ("2" === 2) имеем данные разных типов, и как результат - false.
 
Q2 Зачем подключение внешних скриптов переносят из тега head в конец тега body?
Подключение внешних скриптов в конце тега body используют в том случае, когда скрипт использует контент и нужно быть уверенным, что контент доступен.

Q3 Как устроено наследование в JS? Расскажите о своем опыте реализации JSнаследования.
В JS существуют функциональное наследование и прототипное.
Функциональное наследование реализуется путем вызова функции-конструктора родителя в функции потомке. В результате в функции-потомке пояляются свойства родителя с возможностью их переопределения путем обычного присваивания.
Идеологически прототипное наследование используется для того же. Сущесвенное отличие прототипного наследования заключается в том, что у функции-конструктора появляется свойство prototype, которое содержит прототип объекта и автоматически наследуется для потомка. Например, от одного родителя можно унаследовать 10 раз. После чего изменить в прототипе значение какого-либо свойства и потомки смогу пользоваться новым свойством. И тут важно то, что изменяется именно значение свойство, которое передается по ссылке. Стандарт ECMAScript 6 добавляет синтаксический сахар в виде классов.
Как раз таки классами я и пользовался. Пример: BonusType - модель, описывающая общие свойства для вида бонуса. Модель BonusPoint расширяет BonusType, добавляя свои свойства.

export class BonusPoint extends BonusType {
    private _basedOnType: boolean;
    private _oneWay: boolean;

    constructor(data?: any) {
        super(data);
        if (isTrueObject(data)) {
            this.basedOnType = data.basedOnType;
            this.oneWay = data.oneWay;
        }
    }
    
    public get basedOnType(): boolean {
        return this._basedOnType;
    }
    public set basedOnType(v: boolean) {
        this._basedOnType = v;
    }

    public get oneWay(): boolean {
        return this._oneWay;
    }
    public set oneWay(v: boolean) {
        this._oneWay = v;
    }
}

Q4 Опишите различие использования scope и синтаксиса «Сontroller as» в Angular.js.
Если говорить о компонентном подходе то в scope хранятся данные для всего компонента, а в ControllerAs - данные контроллера. В последних версиях AngularJS при создании контроллера назначается для него имя $ctrl и надобность в ControllerAs отпала, хотя если нужно можно назначить свое имя. Если говорить о различие использования scope и синтаксиса «Сontroller as» в html шаблоне, то оно заключается в следующем: 
	при scope - <input class="inputFind" type="text" ng-model="find" ng-model-options="{ debounce: 500 }"/>
	при ControllerAs - <input class="inputFind" type="text" ng-model="$ctrl.find" ng-model-options="{ debounce: 500 }"/>
Использование scope рекомендуется свести в минимуму и использовать в крайних случаях, например, при HTML5 валидации.

Q5 Когда может понадобиться ручной вызов $digest в Angular.js? Приходилось ли вам его использовать?
Ручной вызов $digest может понадобиться, данные в модели, например, меняются не средствами AngularJS, а например используя setInterval. Мне ручной вызов использовать не приходилось.

Q6 Какие библиотеки можно использовать для написания тестов end-to-end в Angular.js? Расскажите о своем опыте тестирования веб-приложений.
Самая распространенная пожалуй библиотека - Protractor. Опыт тестирования получил в рамках выполнения Level 2 вашего задания.